---
layout: mermaid
title: "Pydantic Introduction"
date: May 18, 2025
---


#### dataclass 
a class decorator that automatically generates special methods for classes, such as __init__, __repr__, and __eq__.

Let’s go deep: when you use `@dataclass`, Python silently generates a bunch of boilerplate methods for you behind the scenes based on your class definition and its fields.

---

#### 📦 Here’s what `@dataclass` auto-generates:

For a simple class like:

```python
from dataclasses import dataclass

@dataclass
class User:
    id: int
    name: str
```

Python automatically creates:

##### ✅ `__init__`

```python
def __init__(self, id: int, name: str):
    self.id = id
    self.name = name
```

---

##### ✅ `__repr__`

Gives a nice string representation:

```python
def __repr__(self):
    return f'User(id={self.id!r}, name={self.name!r})'
```

---

##### ✅ `__eq__`

Equality check based on field values:

```python
def __eq__(self, other):
    if other.__class__ is self.__class__:
        return (self.id, self.name) == (other.id, other.name)
    return NotImplemented
```

---

##### ✅ `__hash__` *(optional — only if `frozen=True` or explicitly requested)*

If `frozen=True` or `unsafe_hash=True` is set:

```python
def __hash__(self):
    return hash((self.id, self.name))
```

---

##### ✅ `__lt__`, `__le__`, `__gt__`, `__ge__` *(if `order=True` is set)*

Comparison operators based on field order:

```python
def __lt__(self, other):
    return (self.id, self.name) < (other.id, other.name)
```

And similarly for `__le__`, `__gt__`, `__ge__`.

---

#### 📌 Control what gets generated:

You can customize what it generates with these parameters:

```python
@dataclass(init=True, repr=True, eq=True, order=False, unsafe_hash=False, frozen=False)
```

---

#### 📦 Bonus: Convert to dict

While `dataclass` doesn’t auto-generate a `to_dict()` method, you can easily get one using:

```python
from dataclasses import asdict

user = User(1, "Kashyap")
print(asdict(user))  # {'id': 1, 'name': 'Kashyap'}
```

---

#### 🔥 Summary Table

| Method                                 | Auto-generated by `@dataclass`    | Purpose                          |
| :------------------------------------- | :-------------------------------- | :------------------------------- |
| `__init__`                             | ✅                                 | Constructor                      |
| `__repr__`                             | ✅                                 | String representation            |
| `__eq__`                               | ✅                                 | Equality comparison              |
| `__hash__`                             | Optional (`frozen`/`unsafe_hash`) | Hash value (for dict keys, sets) |
| `__lt__`, `__le__`, `__gt__`, `__ge__` | If `order=True`                   | Ordering comparisons             |

---




```python
from dataclasses import dataclass
@dataclass
class Person():
    name: str
    age: int
    city: str
```


```python
person = Person(name="John Doe", age=30, city="New York")
print(person)  # Output: John Doe, 30, New York
```

    Person(name='John Doe', age=30, city='New York')
    

#### Pydantic Basics : Creating and using models 
Pydantic models are foundation of data 

#### 📖 What is a `dataclass`?

* Introduced in **Python 3.7**
* It's a **decorator** `@dataclass` that generates boilerplate code for classes (like `__init__`, `__repr__`, `__eq__`, etc.)
* Meant for **lightweight data containers** — no validation, no parsing.

### ✅ Example:

```python
from dataclasses import dataclass

@dataclass
class User:
    id: int
    name: str

user = User(id=1, name="Kashyap")
print(user)
```

✔️ Simple
❌ No data validation — if you pass `User(id="abc", name=123)`, it'll accept it without complaint.

---

#### 📖 What is `pydantic`?

* A **third-party library** for **data validation and settings management** using Python type annotations.
* Similar to `dataclass`, but adds:

  * **Type validation at runtime**
  * **Automatic type coercion**
  * **Better error messages**
  * Optional JSON serialization

##### ✅ Example:

```python
from pydantic import BaseModel

class User(BaseModel):
    id: int
    name: str

user = User(id="1", name=123)  # Pydantic will convert id to int and name to str
print(user)
```

✔️ Type coercion (`"1"` → `1`, `123` → `"123"`)
✔️ Validation errors if it can't convert
✔️ Useful for APIs (FastAPI uses Pydantic extensively)

---

#### 🥊 Dataclass vs Pydantic: Key Differences

| Feature            | `dataclass`                     | `pydantic`                           |
| :----------------- | :------------------------------ | :----------------------------------- |
| Type checking      | No (just type hints)            | Yes (runtime validation + coercion)  |
| Auto conversion    | No                              | Yes                                  |
| Performance        | Faster (no validation overhead) | Slightly slower (due to validation)  |
| JSON Serialization | Manual (or with `asdict()`)     | Built-in (`.json()`, `.dict()`)      |
| Dependencies       | Built-in Python 3.7+            | External library (install via `pip`) |
| Error messages     | None                            | Rich, clear validation errors        |
| Use Case           | Simple data containers          | Data validation, API models, config  |

---

#### 📌 When to Use What?

| If you need…                              | Use         |
| :---------------------------------------- | :---------- |
| Just a lightweight, structured data class | `dataclass` |
| Runtime type validation and parsing       | `pydantic`  |
| Built-in JSON serialization               | `pydantic`  |
| Fast, zero-dependency data objects        | `dataclass` |

---

#### ⚙️ Bonus: You can actually combine them!

```python
from pydantic.dataclasses import dataclass

@dataclass
class User:
    id: int
    name: str

user = User(id="1", name=123)  # Now validated like Pydantic
print(user)
```

---

#### 🔥 TL;DR:

* 📦 `dataclass` = simple, clean data containers with no validation.
* 🛡️ `pydantic` = data models with **validation, coercion, and serialization**.

---

Would you like a side-by-side code demo project to see them in action together? I can spin that up for you too. 🚀



```python
from pydantic import BaseModel
```


```python
class Person1(BaseModel):
    name: str
    age: int
    city: str

    def __str__(self):
        return f"{self.name}, {self.age}, {self.city}"

    def __repr__(self):
        return f"Person(name={self.name}, age={self.age}, city={self.city})"
```


```python
person = Person1(name="John Doe", age=30, city="New York")
print(person)  # Output: name='John Doe' age=30 city='New York'

```

    John Doe, 30, New York
    


```python
person1 = Person1(name="John Doe", age=30, city="35")
print(person1)
```

    John Doe, 30, 35
    

2. Model with Optional Fields

